package ncreep.tracing

import scala.quoted.*

import ncreep.tracing.WithInlining.trace1

object DataFromSignature:

  // we are now going to extract all the tracing metadata directly from the calling method's
  // signature, this includes both the method's name and the method's arguments
  // this way we can automatically trace a method without any manual name and argument passing
  inline def trace5[A](level: TraceLevel)(inline body: A)(using tracer: Tracer): A =
    ${ trace5Impl('level, 'body, 'tracer) }

  def trace5Impl[A: Type](level: Expr[TraceLevel], body: Expr[A], tracer: Expr[Tracer])(using
      Quotes): Expr[A] =
    import quotes.reflect.*

    // we define a new helper method `getEnclosingMethodSymbol` which is just the same
    // logic we've seen before to get the `Symbol` that corresponds to the macro's caller
    // (we'll be reusing it later on as well)
    val enclosingMethod = getEnclosingMethodSymbol

    // `paramSymss` will only return anything useful if this symbol corresponds
    // to a method, which should be checked by `getEnclosingMethodSymbol`
    val allParams = enclosingMethod.paramSymss
      // we don't care about the distinction of the different argument lists
      // we'll be tracing them all, so we can flatten everything into one big
      // list of parameters
      .flatten

    // since argument lists can contain both type arguments and term arguments
    // we only care about tracing the latter
    val onlyTermParams = allParams.filter(_.isTerm)

    // before we convert the parameters into tracing fields, we need to filter
    // out some parameters that we don't want to be traced automatically
    // the filters are defined as separate functions for fluency, jump to
    // each one to see how it's defined
    val params = onlyTermParams
      // `given` parameters are usually "special" (like an instance of a `Tracer`)
      .filterNot(isGiven)
      // by-name parameters are also prone to being special and evaluating them
      // just for tracing might be the wrong thing to do
      .filterNot(isByName)
      // some types might be "untraceable" in the sense that the user doesn't want
      // them logged, for example, if they contain sensitive information
      // in our case the suggestively named `UntraceableData` should not be
      // traced, so we filter it out
      .filterNot(isUntraceable)

    // for every parameter symbol that we get we are going to create a corresponding
    // expression with the tracing field's name and the field's value
    def toField(param: Symbol) =
      // the name is just the parameter's name as it appears in the traced
      // method's argument list
      val fieldName = Expr(param.name)
      // the value is a reference to the argument as it was received by the method
      // we don't really care about its type as we are going to `toString` it
      val fieldValue = Ref(param).asExpr

      // this is again the code that the user had to write manually per field before
      // now it's generated by the macro
      '{ $fieldName -> $fieldValue.toString }

    // we convert every parameter that we want to trace into a tuple of field name and value
    val fieldsList = params.map(toField)
    // and merge everything into one big `Expr` with a `Seq` in it so that we
    // can pass it as varargs below
    val fields = Expr.ofSeq(fieldsList)

    // again we extract the name of the method directly from its symbol
    val name = Expr(enclosingMethod.name)

    // now we have all the info we need, we can create a quote with a call to
    // `trace1` where both the `name` and the `fields` arguments were precomputed by this
    // macro
    // (we could reuse the logic from `trace4Impl` but that would require us to adapt
    // the code a bit so that `fields` are in an unnamed `Vararg` format)
    '{ trace1($level, $name, $fields*)($body)(using $tracer) }

  def isUntraceable(using Quotes)(param: quotes.reflect.Symbol) =
    import quotes.reflect.*

    param.info =:= TypeRepr.of[UntraceableData]
